// def функция(ссылка на первый эл массива(<= 4 символов, может 0), длина массива, адрес результата, код результата)
//     должна перевести строку из 4 ascii символов в число беззнаковое
//     валидация ascii символов
//     если не подходит, то 0 - норм, если ошибка - лююое другое

// --- start - клиентский код
001:  0000 // NOP
002:  0006 // параметр (код результата) - ссылка
003:  0007 // параметр (адрес результата) - ссылка
004:  0004 // параметр (длина массива) - число, длина массива
005:  0008 // параметр (ссылка на 1-й элемент массива) - ссылка
006:  XXXX // сюда запишем код результата
007:  XXXX // сюда запишем результат
008:  XXXX // здесь лежит эл 1
009:  XXXX // здесь лежит эл 2
00A:  XXXX // здесь лежит эл 3
00B:  XXXX // здесь лежит эл 4
00C:+ 0200 // cla
00D:  A002
00E:  0C00 // push - код результата
00F:  A003
010:  0C00 // push - адрес результата
011:  A004
012:  0C00 // push - длина массива
013:  A005
014:  0C00 // push - ссылка на первый эл массива
015:  D100 // call 100
016:  0800 // pop
017:  0800 // pop
018:  0800 // pop
019:  0800 // pop
020:  0100 // HLT - выходим из программы
// --- end - клиентский код

...

// --- start - функция
100:  ac01 // ld st(1)
101:  e201 // сохраняем ссылку на код результата
102:  ac02 // ld st(2)
103:  e202 // сохраняем ссылку на адрес результата
104:  ac03 // ld st(3)
105:  e203 // сохраняем длину массива
106:  A209 // 0 -> AC
107:  7203 // CMP (203), 0
108:  F001 // BEQ
109:  C10B // длина массива не 0
10A:  C18D // jump to success
10B:  AC04 // ld st(4)
10C:  E213 // сохраняем ссылку на первый элемент массива
10D:  A20A // 1 -> AC;                      === start(если 1 элемент)
10E:  7203 // CMP (203), 1
10F:  F10F // BNE 15
110:  C112 // \
111:  0000 // |
112:  A213 // |
113:  E111 //  > сохр первый эл массива
114:  A8FD // |
115:  E204 // /
116:  7214 // CMP (214) == '0', elem1
117:  F203 // BMI 11B если код меньше, чем '0', то error
118:  7215 // CMP (215) == '9', elem1
119:  F301 // BPL 11B если код больше, чем '9', то error
11A:  C11C
11B:  C19A // return error
11C:  6214 // AC - '0'; если здесь, то значение элемента валидно
11D:  E208 // save hex(elem1) -> 208
11E:  С18D // exit with success;            === end(если длина 1)
11F:  A20B // 2 -> AC; если длина не 1;     === start(если 2 элемента)
120:  7203 // CMP (203), 2
121:  F001 // BEQ 123
122:  C156 // если не 2 эл-та, прыгаем к проверке на 3 эл-та
123:  C125 // если 2 эл-та
124:  0000
125:  A213
126:  E124
127:  A8FD
128:  E204
129:  A124 // ссылка на 1 эл-т -> AC
12A:  0700 // INC
12B:  C12D
12C:  0000
12D:  E12C // 12C = ссылка на 2-й элемент
12E:  A8FE
12F:  E205 // значение 2-го эл-та -> 205
130:  A204
131:  7214 // CMP (214) == '0', elem1
132:  F203 // BMI 136 если код меньше, чем '0', то error
133:  7215 // CMP (215) == '9', elem1
134:  F301 // BPL 136 если код больше, чем '9', то error
135:  C137
136:  C19A // return error
137:  A205
138:  7214 // CMP (214) == '0', elem1
139:  F203 // BMI 13D если код меньше, чем '0', то error
13A:  7215 // CMP (215) == '9', elem1
13B:  F301 // BPL 13D если код больше, чем '9', то error
13C:  C13E
13D:  C19A // return error
13E:  A204 // elem1 и elem2 вадидны
13F:  6214 // AC - '0'
140:  E204 // elem1: ascii -> hex
141:  A205
142:  6214 // AC - '0'
143:  E205 // elem2: ascii -> hex
144:  A204 // теперь в 204 и 205 лежат просто числа
145:  E208 // (temp) = (204) = elem1
146:  C148 // столько раз, сколько в (205), добавить 10 = (216) к (208)
147:  0000 // tempN, столько раз должен выполниться цикл
148:  A205
149:  E147
14A:  A147 // начало цикла
14B:  7209 // CMP (209) = 0, AC ; если (147) == 0
14C:  F001 // BEQ 14E
14D:  C14F // если цикл еще не выполнился
14E:  C155 // если цикл выполнился
14F:  0740 // \
150:  E147 //  > (147) -= 1
151:  A208 // \
152:  4216 // |
153:  E208 //  > (208) += 10
154:  C14A // JUMP 14A - в начало цикла
155:  C18D // цикл выполнился; === end(если 2 элемента)
156:  A20C // 3 -> AC; если длина не 2;     === start(если 3 элемента)
157:  0000 // NOP
158:  7203 // CMP (203), 3
159:  F001 // BEQ 15B
15A:  C23C // если не 3 эл-та, прыгаем к проверке на 4 эл-та
15B:  C15D // если 3 эл-та
15C:  0000
15D:  A213
15E:  E15C
15F:  A8FD
160:  E204
161:  A15C // ссылка на 1 эл-т -> AC
163:  0700 // INC
163:  C165
164:  0000
165:  E164 // 164 = ссылка на 2-й элемент
166:  A8FE
167:  E205 // значение 2-го эл-та -> 205
168:  A15C // ссылка на 1 эл-т -> AC
169:  420B // ADD 2
16A:  C16C
16B:  0000
16C:  E16B // 16B = ссылка на 3-й элемент
16D:  A8FE
16E:  E206 // значение 3-го эл-та -> 206
16F:  A204 // 1 эл
170:  7214 // CMP (214) == '0', elem1
171:  F203 // BMI 175 если код меньше, чем '0', то error
172:  7215 // CMP (215) == '9', elem1
173:  F301 // BPL 175 если код больше, чем '9', то error
174:  C176
175:  C19A // return error
176:  A205 // 2 эл
177:  7214 // CMP (214) == '0', elem1
178:  F203 // BMI 17C если код меньше, чем '0', то error
179:  7215 // CMP (215) == '9', elem1
17A:  F301 // BPL 17C если код больше, чем '9', то error
17B:  C17D
17C:  C19A // return error
17D:  A206 // 3 эл
17E:  7214 // CMP (214) == '0', elem1
17F:  F203 // BMI 183 если код меньше, чем '0', то error
180:  7215 // CMP (215) == '9', elem1
181:  F301 // BPL 183 если код больше, чем '9', то error
182:  C184
183:  C19A // return error
184:  A204 // elem1, elem2, elem3 вадидны
185:  6214 // AC - '0'
186:  E204 // elem1: ascii -> hex
187:  A205
188:  6214 // AC - '0'
189:  E205 // elem2: ascii -> hex
18A:  C218 // продолжим после блока данных
18B:  0000 // NOP
18C:  03E8 // 1000
18D:  C18F // <- jump here if success -------- // ==== DATA & RETURN
18E:  0000
18F:  A202
190:  E18E
191:  A208 // промежуточный результат
192:  E8FC
193:  C195
194:  0000
195:  A201
196:  E194
197:  A209 // = 0 - код успех
198:  E8FC
199:  0A00 // return success
19A:  C19C // <- jump here if error ------------
19B:  0000
19C:  A201
19D:  E19B
19E:  A20A // = 1 - код ошибки
19F:  E8FC
200:  0A00 // return error
201:  0000 // храним ссылку на код результата
202:  0000 // храним ссылку на адрес результата
203:  0000 // храним длину массива
204:  0000 // храним первый элемент массива
205:  0000 // храним второй элемент массива
206:  0000 // храним третий элемент массива
207:  0000 // храним четвертый элемент массива
208:  0000 // промежуточное значение результата
209:  0000 // 0
20A:  0001 // 1
20B:  0002 // 2
20C:  0003 // 3
20D:  0004 // 4
20E:  0005 // 5
20F:  0006 // 6
210:  0007 // 7
211:  0008 // 8
212:  0009 // 9
213:  0000 // храним ссылку на на первый элемент массива
214:  0030 // ascii '0'
215:  0039 // ascii '9'
216:  000A // 10
217:  0064 // 100 // ============================= DATA & RETURN
218:  A206
219:  6214 // AC - '0'
21A:  E206 // elem3: ascii -> hex
21B:  A204 // теперь в 204, 205, 206 лежат просто числа
21C:  E208 // (temp) = (204) = elem1
21D:  C21F // столько раз, сколько в el2 = (205), добавить 10 = (216) к (208)
21E:  0000 // tempN, столько раз должен выполниться цикл
21F:  A205
220:  E21E
221:  A21E // начало цикла
222:  7209 // CMP (209) = 0, AC ; если (21E) == 0
223:  F001 // BEQ 225
224:  C226 // если цикл еще не выполнился
225:  C22C // если цикл выполнился
226:  0740 // \ - DEC
227:  E21E //  > (21E) -= 1
228:  A208 // \
229:  4216 // |
22A:  E208 //  > (208) += 10
22B:  C221 // JUMP 221 - в начало цикла
22C:  C22E // цикл выполнился; обработан 2-й разряд
22D:  0000 // tempN+1, столько раз должен выполниться цикл2
22E:  A206 // elem3
22F:  E22D
230:  A22D // начало цикла
231:  7209 // CMP (209) = 0, AC ; если (22D) == 0
232:  F001 // BEQ 234
233:  C235 // если цикл еще не выполнился
234:  C23B // если цикл выполнился
235:  0740 // \ - DEC
236:  E22D //  > (22D) -= 1
237:  A208 // \
238:  4217 // |
239:  E208 //  > (208) += 100
23A:  C230 // JUMP 230 - в начало цикла
23B:  C18D // цикл выполнился;              === end(если 3 элемента)
23C:  A20D // 4 -> AC; если длина не 3;     === start(если 4 элемента)
23D:  0000 // NOP
23E:  7203 // CMP (203), 4
23F:  F001 // BEQ 241
240:  C19A // если не 4 эл-та, то ошибка
241:  C243 // если 4 эл-та
242:  0000
243:  A213
244:  E242
245:  A8FD
246:  E204
247:  A242 // ссылка на 1 эл-т -> AC
248:  0700 // INC
249:  C24B
24A:  0000
24B:  E24A // 24A = ссылка на 2-й элемент
24C:  A8FE
24D:  E205 // значение 2-го эл-та -> 205
24E:  A242 // ссылка на 1 эл-т -> AC
24F:  420B // ADD 2
250:  C252
251:  0000
252:  E251 // 251 = ссылка на 3-й элемент
253:  A8FE
254:  E206 // значение 3-го эл-та -> 206
255:  A242 // ссылка на 1 эл-т -> AC
256:  420C // ADD 3
257:  C259
258:  0000
259:  E258 // 258 = ссылка на 4-й элемент
25A:  A8FE
25B:  E207 // значение 4-го эл-та -> 207
25C:  A204 // 1 эл
25D:  7214 // CMP (214) == '0', elem1
25E:  F203 // BMI 261 если код меньше, чем '0', то error
25F:  7215 // CMP (215) == '9', elem1
260:  F301 // BPL 261 если код больше, чем '9', то error
261:  C263
262:  C19A // return error
263:  A205 // 2 эл
264:  7214 // CMP (214) == '0', elem1
265:  F203 // BMI 269 если код меньше, чем '0', то error
266:  7215 // CMP (215) == '9', elem1
267:  F301 // BPL 269 если код больше, чем '9', то error
268:  C26A
269:  C19A // return error
26A:  A206 // 3 эл
26B:  7214 // CMP (214) == '0', elem1
26C:  F203 // BMI 270 если код меньше, чем '0', то error
26D:  7215 // CMP (215) == '9', elem1
26E:  F301 // BPL 270 если код больше, чем '9', то error
26F:  C271
270:  C19A // return error
271:  A207 // 4 эл
272:  7214 // CMP (214) == '0', elem1
273:  F203 // BMI 277 если код меньше, чем '0', то error
274:  7215 // CMP (215) == '9', elem1
275:  F301 // BPL 277 если код больше, чем '9', то error
276:  C278
277:  C19A // return error
278:  A204 // elem1, elem2, elem3, elem4 вадидны
279:  6214 // AC - '0'
27A:  E204 // elem1: ascii -> hex
27B:  A205
27C:  6214 // AC - '0'
27D:  E205 // elem2: ascii -> hex
27E:  A206
27F:  6214 // AC - '0'
280:  E206 // elem3: ascii -> hex
281:  A207
282:  6214 // AC - '0'
283:  E207 // elem4: ascii -> hex
284:  A204 // теперь в 204, 205, 206, 207 лежат просто числа
285:  E208 // (temp) = (204) = elem1
286:  C288 // столько раз, сколько в el2 = (205), добавить 10 = (216) к (208)
287:  0000 // tempN, столько раз должен выполниться цикл
288:  A205
289:  E287
28A:  A287 // начало цикла
28B:  7209 // CMP (209) = 0, AC ; если (287) == 0
28C:  F001 // BEQ 28E
28D:  C28F // если цикл еще не выполнился
28E:  C295 // если цикл выполнился
28F:  0740 // \ - DEC
290:  E287 //  > (287) -= 1
291:  A208 // \
292:  4216 // |
293:  E208 //  > (208) += 10
294:  C28A // JUMP 28A - в начало цикла
295:  C297 // цикл выполнился; обработан 2-й разряд
296:  0000 // tempN+1, столько раз должен выполниться цикл2
297:  A206 // elem3
298:  E296
299:  A296 // начало цикла
29A:  7209 // CMP (209) = 0, AC ; если (296) == 0
29B:  F001 // BEQ 29D
29C:  C29E // если цикл еще не выполнился
29D:  C304 // если цикл выполнился
29E:  0740 // \ - DEC
29F:  E296 //  > (296) -= 1
300:  A208 // \
301:  4217 // |
302:  E208 //  > (208) += 100
303:  C299 // JUMP 299 - в начало цикла
304:  C306 // цикл выполнился; обработан 3-й разряд
305:  0000 // tempN+2, столько раз должен выполниться цикл3
306:  A207 // elem4
307:  E305
308:  A305 // начало цикла
309:  7209 // CMP (209) = 0, AC ; если (305) == 0
30A:  F001 // BEQ 30C
30B:  C30D // если цикл еще не выполнился
30C:  C313 // если цикл выполнился
30D:  0740 // \ - DEC
30E:  E305 //  > (305) -= 1
30F:  A208 // \
310:  418C // |
311:  E208 //  > (208) += 1000
312:  C308 // JUMP 308 - в начало цикла
313:  C18D // цикл выполнился;              === end(если 4 элемента)
314:  0000 // NOP
// --- end - функция
