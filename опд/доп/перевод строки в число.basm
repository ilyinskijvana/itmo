// def функция(ссылка на первый эл массива(<= 4 символов, может 0), длина массива, адрес результата, код результата)
//     должна перевести строку из 4 ascii символов в число беззнаковое
//     валидация ascii символов
//     если не подходит, то 0 - норм, если ошибка - лююое другое

// --- start - клиентский код
001:  0000 // NOP
002:  0006 // параметр (код результата) - ссылка
003:  0007 // параметр (адрес результата) - ссылка
004:  0004 // параметр (длина массива) - число, длина массива
005:  0008 // параметр (ссылка на 1-й элемент массива) - ссылка
006:  XXXX // сюда запишем код результата
007:  XXXX // сюда запишем результат
008:  XXXX // здесь лежит эл 1
009:  XXXX // здесь лежит эл 2
00A:  XXXX // здесь лежит эл 3
00B:  XXXX // здесь лежит эл 4
00C:+ 0200 // cla
00D:  A002
00E:  0C00 // push - код результата
00F:  A003
010:  0C00 // push - адрес результата
011:  A004
012:  0C00 // push - длина массива
013:  A005
014:  0C00 // push - ссылка на первый эл массива
015:  D100 // call 100
016:  0800 // pop
017:  0800 // pop
018:  0800 // pop
019:  0800 // pop
020:  0100 // HLT - выходим из программы
// --- end - клиентский код

...

// --- start - функция
100:  ac01 // ld st(1)
101:  e201 // сохраняем ссылку на код результата
102:  ac02 // ld st(2)
103:  e202 // сохраняем ссылку на адрес результата
104:  ac03 // ld st(3)
105:  e203 // сохраняем длину массива
106:  A209 // 0 -> AC
107:  7203 // CMP (203), 0
108:  F001 // BEQ
109:  C10B // длина массива не 0
10A:  C18D // jump to success
10B:  AC04 // ld st(4)
10C:  E213 // сохраняем ссылку на первый элемент массива
10D:  A20A // 1 -> AC;                      === start(если 1 элемент)
10E:  7203 // CMP (203), 1
10F:  F10F // BNE 15
110:  C112 // \
111:  0000 // |
112:  A213 // |
113:  E111 //  > сохр первый эл массива
114:  A8FD // |
115:  E204 // /
116:  7214 // CMP (214) == '0', elem1
117:  F203 // BMI 11B если код меньше, чем '0', то error
118:  7215 // CMP (215) == '9', elem1
119:  F301 // BPL 11B если код больше, чем '9', то error
11A:  C11C
11B:  C19A // return error
11C:  6214 // AC - '0'; если здесь, то значение элемента валидно
11D:  E208 // save hex(elem1) -> 208
11E:  С18D // exit with success;            === end(если длина 1)
11F:  A20B // 2 -> AC; если длина не 1;     === start(если 2 элемента)
120:  7203 // CMP (203), 2
121:  F001 // BEQ 123
122:  C156 // если не 2 эл-та, прыгаем к проверке на 3 эл-та
123:  C125 // если 2 эл-та
124:  0000
125:  A213
126:  E124
127:  A8FD
128:  E204
129:  A124 // ссылка на 1 эл-т -> AC
12A:  0700 // INC
12B:  C12D
12C:  0000
12D:  E12C // 12C = ссылка на 2-й элемент
12E:  A8FE
12F:  E205 // значение 2-го эл-та -> 205
130:  A204
131:  7214 // CMP (214) == '0', elem1
132:  F203 // BMI 136 если код меньше, чем '0', то error
133:  7215 // CMP (215) == '9', elem1
134:  F301 // BPL 136 если код больше, чем '9', то error
135:  C137
136:  C19A // return error
137:  A205
138:  7214 // CMP (214) == '0', elem1
139:  F203 // BMI 13D если код меньше, чем '0', то error
13A:  7215 // CMP (215) == '9', elem1
13B:  F301 // BPL 13D если код больше, чем '9', то error
13C:  C13E
13D:  C19A // return error
13E:  A204 // elem1 и elem2 вадидны
13F:  6214 // AC - '0'
140:  E204 // elem1: ascii -> hex
141:  A205
142:  6214 // AC - '0'
143:  E205 // elem2: ascii -> hex
144:  A204 // теперь в 204 и 205 лежат просто числа
145:  E208 // (temp) = (204) = elem1
146:  C148 // столько раз, сколько в (205), добавить 10 = (216) к (208)
147:  0000 // tempN, столько раз должен выполниться цикл
148:  A205
149:  E147
14A:  A147 // начало цикла
14B:  7209 // CMP (209) = 0, AC ; если (147) == 0
14C:  F001 // BEQ 14E
14D:  C14F // если цикл еще не выполнился
14E:  C155 // если цикл выполнился
14F:  0740 // \
150:  E147 //  > (147) -= 1
151:  A208 // \
152:  4216 // |
153:  E208 //  > (208) += 10
154:  C14A // JUMP 14A - в начало цикла
155:  C18D // цикл выполнился; === end(если 2 элемента)
156:  XXXX // start(если 3 элемента)
157:  
158:  

...

18D:  C18F // <- jump here if success --------
18E:  0000
18F:  A202
190:  E18E
191:  A208 // промежуточный результат
192:  E8FC
193:  C195
194:  0000
195:  A201
196:  E194
197:  A209 // = 0 - код успех
198:  E8FC
199:  0A00 // return success
19A:  C19C // <- jump here if error ------------
19B:  0000
19C:  A201
19D:  E19B
19E:  A20A // = 1 - код ошибки
19F:  E8FC
200:  0A00 // return error
201:  0000 // храним ссылку на код результата
202:  0000 // храним ссылку на адрес результата
203:  0000 // храним длину массива
204:  0000 // храним первый элемент массива
205:  0000 // храним второй элемент массива
206:  0000 // храним третий элемент массива
207:  0000 // храним четвертый элемент массива
208:  0000 // промежуточное значение результата
209:  0000 // 0
20A:  0001 // 1
20B:  0002 // 2
20C:  0003 // 3
20D:  0004 // 4
20E:  0005 // 5
20F:  0006 // 6
210:  0007 // 7
211:  0008 // 8
212:  0009 // 9
213:  0000 // храним ссылку на на первый элемент массива
214:  0030 // ascii '0'
215:  0039 // ascii '9'
216:  000A // 10
217:  0064 // 100
// --- end - функция
